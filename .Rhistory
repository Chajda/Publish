data(mtcars)
library(swirl)
swirl()
install.packages("swirl")
install.packages("swirl")
install.packages("swirl")
install.packages("swirl")
library(swirl)
swirl()
install.packages("swirl")
install.packages("swirl", dependencies = FALSE)
install.packages("swirl")
library(swirl)
swirl()
install.packages("swirl")
library(swirl)
swirl()
fit <- lm(y ~ x, out2)
plot(fit, which=1)
fitno <- lm(y ~ x, out2[-1,])
plot(fitno, which=1)
coef(fit)-coef(fitno)
view(dfbeta(fit))
head(dfbeta(fit))
resno
| <- out2[1, "y"] - predict(fitno, out2[1,])
resno <- out2[1, "y"] - predict(fitno, out2[1,])
1-resid(fit)[1]/resno
head(hatvalues(fit))
sigma <- sqrt(sum(resid(fit)^2))
sigma <- sqrt(deviance(fit)/df.residual(fit))
rstd <- x/sigma*sqrt(1-hatvalues(fit))
rstd <- sqrt(1-hatvalues(fit))/sigma*sqrt(1-hatvalues(fit))
rstd <- resid(fit)/(sigma * sqrt(1-hatvalues(fit)))
head(cbind(rstd, rstandard(fit)))
plot(fit, which=3)
plot(fit,which=2)
sigma1 <- sqrt(1)
sigma1 <- sqrt(deviance(fitno)/df.residual(fitno))
sigma1/sqrt(1-hatvalues(fit)[1])
resid(fit)[1]/(sigma1*sqrt(1-hatvalues(fit)[1]))
head(rstudent(fit))
predict(fitno, out2)-predict(fit, out2)
dy <- predict(fitno, out2)-predict(fit, out2)
dy/(2*sigma^2)
sum(dy^2)/(2*sigma^2)
plot(fit, which=5)
rgp1()
rgp2()
head(swiss)
mdl <- lm(Fertility ~ .*)
mdl <- lm(Fertility ~ .)
mdl <- lm(Fertility ~ ., mtcar)
mdl <- lm(Fertility ~ ., out1)
mdl <- lm(out1 ~ ., out1)
mdl <- lm(out1[2,] ~ ., out1)
mdl <- lm(out1[1,] ~ ., out1)
mdl <- lm(out1[1,] ~ out1[2,], out1)
mdl <- lm(c(1,2)~c(3,4))
mdl <- lm(Fertility ~ ., swiss)
vif(mdl)
mdl2 <- lm(Fertility ~ ., swiss)
mdl2 <- lm(Fertility ~ . -Examination, swiss)
vif(mdl2)
x1c <- simbias()
apply(x1c, 1, mean)
fit1 <- 1
fit!
fit1
swirl()
fit1
fit1 <- lm(Fertility ~ Agriculture, swiss)
fit3 <- lm(Fertility ~ Agriculture + Examination + Education, swiss)
anova(fit1,fit3)
deviance(fit3)
d<-deviance(fit3)/43
n<- (deviance(fit1)-deviance(fit3))/2
n/d
pf(n/d, 2, 43, lower.tail=FALSE)
shapiro.test(fit3$residuals)
anova(fit1, fit3, fit5, fit6)
ravenData
mdl <- glm(ravenWinNum ~ ravenScore)
mdl <- glm(ravenWinNum ~ ravenScore, family)
mdl <- glm(ravenWinNum ~ ravenScore, family, ravenData)
mdl <- glm(ravenWinNum ~ ravenScore, 'family', ravenData)
mdl <- glm(ravenWinNum ~ ravenScore, ravenData)
glm(ravenWinNum ~ ravenScore, ravenData)
mdl
mdl <- glm(ravenWinNum ~ ravenScore, family=binomial, data=ravenData)
lodds<-predict(mdl, data.frame(ravenScore=c(0, 3, 6)))
exp(lodds)/(1+exp(lodds))
summary(mdl)
confint(mdl)
exp(confint(mdl))
anova(mdl)
qchisq(0.95, 1)
var(rpois(1000, 50))
nxt()
head(hits)
class(hits[,'date'])
as.integer(head(hits[,'date']))
mdl <- glm(visits ~ date, poisson, hits)
summary(mdl)
confint(mdl, 'date')
exp(confint(mdl, 'date'))
which.max(hits[,'visits'])
hits[704,]
mdl$fitted.values[704]
lambda <- mdl$fitted.values[704]
qpois(.95, lambda)
mdl2 <- glm()
mdl2 <- glm(1~1)
mdl2 <- glm(formula = simplystats ~ date, family = poisson, data = hits, offset = log(visits + 1))
qpois(.95, mdl2$fitted.values[704])
rm(list=ls())
q()
q()
library(AppliedPredictiveModeling)
library(caret)
data(AlzheimerDisease)
install.packages("AppliedPredictiveModeling")
install.packages("caret")
library(AppliedPredictiveModeling)
library(caret)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
trainIndex = createDataPartition(diagnosis, p = 0.50,list=FALSE)
training = adData[trainIndex,]
testing = adData[-trainIndex,]
library(AppliedPredictiveModeling)
data(concrete)
library(caret)
set.seed(1000)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
training = mixtures[ inTrain,]
testing = mixtures[-inTrain,]
hist(training)
names(training)
hist(training$Superplasticizer)
hist(testing$Superplasticizer)
hist(adData$Superplasticizer)
names(adData)
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
names(training)
?substr
substr(names(training),1,2)
substr(names(training),0,2)
substr(names(training),0,1)
substr(names(training),0,1)='L'
substr(names(training),0,1)=='L
\
;'
substr(names(training),0,1)=='L'
names(training)
substr(names(training),0,1)=='L'
substr(names(training),1,1)=='L'
substr(names(training),1,2)=='L'
substr(names(training),1,2)
names(training)
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
substr(names(training),0,1)
x <- substr(names(training),1,2)=='L'
x
names(training)
x
substr(names(training),1,2)=='L'
substr(names(training),0,1)=='L'
x <- substr(names(training),0,1)=='L'
names(training)[x]
n <- names(training)[x]
x <- substr(names(training),0,2)=='IL'
n <- names(training)[x]
n
?preProcess
preProcess(train[,n], thresh=.90)
preProcess(train, thresh=.90)
preProcess(train[n], thresh=.90)
subset = training[,grep("^IL", names(training))]
preProcess(subset, thresh = 0.8, method = "pca")$numComp
preProcess(training, thresh = 0.8, method = "pca")$numComp
length(n)
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
trainSubset = training[,grep("^IL", names(training))]
testSubset = testing[,grep("^IL", names(testing))]
pp = preProcess(trainSubset, thresh = 0.8, method = "pca")
trainTransformed <- predict(pp, trainSubset)
testTransformed <- predict(pp, testSubset)
trainSubset$diagnosis = training$diagnosis
testSubset$diagnosis = testing$diagnosis
trainTransformed$diagnosis = training$diagnosis
testTransformed$diagnosis = testing$diagnosis
glmpca = train(diagnosis ~ ., data = trainTransformed, method = "glm")
glm = train(diagnosis ~ ., data = trainSubset, method = "glm")
round(confusionMatrix(testSubset$diagnosis,predict(glm, testSubset))$overall["Accuracy"],2)
round(confusionMatrix(testTransformed$diagnosis,predict(glmpca, testTransformed))$overall["Accuracy"],2)
rm(list=ls())
fileName <- "C:\\Users\\ichaloup\\Desktop\\gold.csv"
??csv
read.table(file=fileName, header=TRUE, sep="|", dec=".")
read.table(file=fileName, header=TRUE, sep=";", dec=".")
library(Defaults)
instal.packages("Defaults")
install.packages("Defaults")
library(Defaults)
setClass("myDate")
setAs("character","myDate", function(from) as.POSIXct(from, format="%d.%m.%Y"))
read.table(file=fileName, header=TRUE, sep=";", dec="."; colClasses = c("myDate","numeric"))
read.table(file=fileName, header=TRUE, sep=";", dec=".", colClasses = c("myDate","numeric"))
input <- read.table(file=fileName, header=TRUE, sep=";", dec=".", colClasses = c("myDate","numeric"))
summary(input)
plot(input)
line(input)
?plot
plot(input, type="p")
plot(input, type="l")
plot(input, type="h")
plot(input, type="l")
names(input)
plot(x=input$Datum, y=input$Cena, type="l")
plot(x=input$Datum, y=input$Cena, type="l")
head(input$Datum)
plot(x=input$Datum, y=input$Cena, type="l", title="Input data")
plot(x=input$Datum, y=input$Cena, type="l", name="Input data")
plot(x=input$Datum, y=input$Cena, type="l", main="Input data")
dim(input)
?createDataPartition
N <- dim(input)[1]
N
s <- 0
for (i <- 1:(N-1)) {
s <- s + input$Cena[i]
}
s <- 0
for (i <- 1:(N-1)) (
s <- s + input$Cena[i]
)
s <- 0
for (i <- 1:(N-1)) (
s <- s + input$Cena[i]
)
s <- 0
for (i in 1:(N-1))
s <- s + input$Cena[i]
s <- 0
for (i in 1:(N-1)) {
s <- s + input$Cena[i]
}
for (i in 1:(N)) {
s[i] <- input$Cena[i]-input$Cena[i-1]
}
rm(ls=c('s'))
input$Cena[0\]
input$Cena[0]
input[0,]
input[1,]
for (i in 2:N) {
s[i] <- input$Cena[i]-input$Cena[i-1]
}
plot(s)
head(input)
for (i in 1:N-1) {
s[i] <- input$Cena[i]-input$Cena[i+1]
}
plot(s)
plot(s, type="l")
plot(s[s=0])
plot(s[s==0])
plot(input[s==0])
plot(input[s==0])
plot(input$Cena[s==0])
plot(input$Cena[abs(s)<0.001])
plot(input$Cena[abs(s)<0.01])
plot(input$Cena[abs(s)<0.1])
plot(s, type="l")
plot(input$Cena[abs(s)<0.1])
input$Cena[abs(s)<0.1]
input[abs(s)<0.1]
table(input[abs(s)<0.1])
data.frame(input[abs(s)<0.1])
input[abs(s)<0.1
]
input[abs(s)<0.1,]
plot(input$Cena[abs(s)<0.1])
buy <- input[abs(s)<0.1,]
buy
buy[1,1]
buy[1,0]
library(manipulate)
myPlot <- function(s) {
plot(cars$dist - mean(cars$dist), cars$speed - mean(cars$speed))
abline(0, s)
}
?manipulate
manipulate(myPlot(s), s = slider(0, 2, step = 0.1))
manipulate(myPlot(s), x.s = slider(0, 2, step = 0.1))
manipulate(myPlot, s = slider(0, 2, step = 0.1))
dTable(airquality, sPaginationType = "full_numbers")
library(rCharts)
install.packages("rCharts")
library(rCharts)
install.packages("devtools")
library(devtools)
install.packages("Rtools")
library(slidify)
publish(user='Chajda', repo='Publish')
slidify('index.Rmd')
getwd()
setwd("C:/Users/ichaloup/Documents/Slidify")
slidify('index.Rmd')
library(Slidify)
library(slidify)
slidify('index.Rmd')
getwd
getwd()
setwd("C:/Users/ichaloup/Documents/Slidify/Chajda")
slidify('index.Rmd')
publish(user='Chajda', repo='Publish')
